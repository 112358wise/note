压力测试

webbench -c 200 -t 60 http://down.chinaz.com/index.php
-c 并发数
-t 持续时间（秒）

ab stands for apache bench
ab [options] [http[s]://]hostname[:port]/path
-n 请求数
-c 并发数
-t 持续时间
=================

事件模块
事件处理框架所要解决的问题是如何收集、管理、分发事件，事件主要是网络事件和定时器事件。
=================

事件驱动机制/IO多路复用
epoll机制
epoll_create(): 产生一个epoll对象，返回指向该epoll对象的文件描述符
epoll_ctl(): 将感兴趣的文件描述符注册到epoll对象
epoll_wait(): 等待事件发生

调用epoll_create建立一个epoll对象（在epoll文件系统中给这个句柄分配资源）、调用epoll_ctl向epoll对象中添加这100万个连接的套接字、调用epoll_wait收集发生事件的连接。

调用epoll_create方法，linux内核会创建一个eventpoll结构体，包含两个成员双向链表rdllist和红黑树根节点rbr。rdllist保存通过epoll_wait返回给用户的满足条件的事件，rbr存储所有通过epoll_ctl添加到epoll中的事件。在epool中，对于每一个事件都会建立一个epitem结构体，rdllist和rbr就是基于epitem中的rdllink和rbn成员组织的。
==================

ngx_events_module
核心模块
nginx把不同操作系统的IO模型抽象封装成ngx_event_module_t.actions中指定的钩子。
typedef struct {
    ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
    ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

    ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
    ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

    ngx_int_t  (*add_conn)(ngx_connection_t *c);
    ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);

    ngx_int_t  (*process_changes)(ngx_cycle_t *cycle, ngx_uint_t nowait);
    ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
                   ngx_uint_t flags);

    ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
    void       (*done)(ngx_cycle_t *cycle);
} ngx_event_actions_t;

typedef struct {
    ngx_str_t            *name;

    void                 *(*create_conf)(ngx_cycle_t *cycle);
    char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

    ngx_event_actions_t     actions;
} ngx_event_module_t;

worker 初始化的时候会调用actions.init钩子初始化IO模型，比如在epoll的init钩子会创建epoll句柄和事件队列；之后worker就可以在监听套接口上添加对连接建立状态的监听事件，调用accept获取已连接套接口，在已连接套接口上添加对读写操作的监听事件，nginx会调用 actions.process_events钩子轮询和处理事件，轮询有超时设定。

ngx_event_core_module
事件模块，决定使用哪种事件驱动机制，以及如何管理事件。

==================

event结构

struct ngx_event_t {
    void            *data;             //通常指向ngx_connection_t连接对象

    unsigned         write:1;          //事件可写，即处于可发生网络包的状态

    unsigned         accept:1;         //事件可建立新连接

    unsigned         instance:1;       //区分当前事件是否过期，用于事件驱动模块（如epoll）

    unsigned         active:1;         //当前事件是活跃的

    unsigned         ready:1;          //当前事件是否准备就绪

    /* aio operation is complete */
    unsigned         complete:1;

    unsigned         eof:1;            //当前处理的字节流已经结束

    unsigned         error:1;          //事件在处理过程中出错

    unsigned         timedout:1;       //事件已经超时
    unsigned         timer_set:1;

    unsigned         delayed:1;        //延迟处理改事件，用于限速功能

    unsigned         deferred_accept:1;//延迟建立TCP连接，三次握手后不建立连接，到真正收到数据包时建立

    unsigned         available:1;      //一次尽可能多地建立TCP连接，与multi_accecpt对应

    ngx_event_handler_pt  handler;     //事件处理函数，每个事件消费模块都会重新实现它*****

    ngx_log_t       *log;              //用于记录error_log日志

    ngx_rbtree_node_t   timer;         //定时器

    /* the links of the posted queue */
    ngx_event_t     *next;
    ngx_event_t    **prev;

    //其他标志位成员，省略...
};

事件是不需要创建的，Nginx在启动时已经在ngx_cycle_t结构的read_events成员中预分配了所有的读事件，在write_events成员中预分配了所有的写事件。

Nginx封装的两个简单方法用于在事件驱动模块中添加或者移除事件：
ngx_int_t ngx_handle_read_event(ngx_event_t *rev, ngx_uint_t flags);
ngx_int_t ngx_handle_write_event(ngx_evnet_t *wev, size_t lowat);

